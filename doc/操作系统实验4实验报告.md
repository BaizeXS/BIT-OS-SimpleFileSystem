# 操作系统实验4——实现简单的文件系统

### 1. 实验目的

本次实验，我们需要理解文件系统的概念和原理，包括文件的组织结构、目录管理和文件操作等。其次需要学习文件系统的设计和实现原则，包括文件的存储管理、文件的索引和访问控制等。第三，掌握实现简单文件系统的基本步骤和技巧也是必不可少的。随后，还需要熟悉文件系统中的文件操作，如创建、打开、读写和删除文件等。具体要求如下：

1. 在内存中开辟一个虚拟磁盘空间作为文件存储器，在其上实现一个简单的单用户文件系统。在退出这个简单的文件系统时，将该虚拟文件系统保存到磁盘上，以便下次再将它恢复到内存的虚拟磁盘空间中。
2. 该文件系统能够提供以下操作：
   - new：建立一个新的简单文件系统
   - sfs：打开一个简单文件系统
   - exit：退出打开的简单文件系统
   - mkdir：创建子目录
   - rmdir：删除子目录
   - ls：显示目录
   - cd：更改当前目录
   - create：创建文件
   - open：打开文件
   - close：关闭文件
   - read：读文件
   - write：写文件
   - delete：删除文件

### 2. 数据结构和符号说明

本次实验使用 Java 进行编程，并借助面向对象的思想对操作系统的文件系统进行模拟。

- Main 类

  简单文件系统的入口，该类用于模拟 shell，接受命令来创建文件系统、打开文件系统、退出终端等功能。

  ```java
  import java.util.Scanner;
  
  public class Main {
      public static void main(String[] args) {
          SimpleFileSystem fileSystem = null;
          Scanner in = new Scanner(System.in);
          label:
          while (true) {
              System.out.print("> ");
              String command = in.next();
              switch (command) {
                  // 创建文件系统
                  case "new" -> {
                      if (fileSystem == null) {
                          System.out.println("VirtualFile System is created.");
                          fileSystem = new SimpleFileSystem();
                      } else {
                          System.out.println("VirtualFile System already exists.");
                      }
                  }
                  // 启动文件系统
                  case "sfs" -> {
                      if (fileSystem != null) {
                          System.out.println("VirtualFile System is running.");
                          fileSystem.run();
                      } else {
                          System.out.println("VirtualFile System is not existed. You can use \"new\" to create one!");
                      }
                  }
                  // 退出终端
                  case "exit" -> {
                      System.out.println("Exiting the shell.");
                      in.close();
                      break label;
                  }
                  default -> System.out.println("Invalid command.");
              }
          }
      }
  }
  ```

- DirectoryEntry

  该类为文件目录项，该类有三个成员变量：

  - name：文件名/目录名
  - isDirectory：该对象是否为文件的目录项
  - parentDir：该文件/目录的所属目录

  此外，该类有两个子类，分别为文件的目录项和目录的目录项：

  - 文件目录项

    在Unix系统中，文件由文件控制块和文件体组成。文件控制块由文件目录项和文件索引节点（inode 节点）组成。文件目录项中包含了文件的名称和文件索引节点号（inode 节点号），通过文件文件索引节点号即可访问文件索引节点。文件索引节点中包含了文件的其他属性，例如文件大小、文件打开标志、文件索引表。文件索引表存储了文件逻辑块号和物理块号的对应关系。本实验由 Java 实现，在 Java 中对象为引用类型，类似于 C 语言中的指针，因此不需要在文件目录项目中设置文件索引节点号，而是直接设置一个文件对象即可。
    ```java
    import java.io.Serializable;
    
    public class DirectoryFile extends DirectoryEntry implements Serializable {
        public VirtualFile file;                       // 文件
    
        public DirectoryFile(String name, boolean isDirectory, Directory parentDir) {
            super(name, isDirectory, parentDir);
            this.file = new VirtualFile();
        }
    
        @Override
        public String toString() {
            return "DirectoryFile{" +
                    "virtualFile=" + file +
                    ", name='" + name + '\'' +
                    ", isDirectory=" + isDirectory +
                    ", parentDir=" + parentDir +
                    '}';
        }
    }
    
    ```

  - 目录目录项

    该类用于表示目录的目录项，该类包含一个哈希表，用来映射文件名和文件目录项。哈希表还有一项优势是速度较快，便于目录的查询。

    ```java
    import java.io.Serializable;
    import java.util.HashMap;
    
    public class Directory extends DirectoryEntry implements Serializable {
        public HashMap<String, DirectoryEntry> dirTable;        // 目录表
    
        public Directory(String name, boolean isDirectory, Directory parentDir) {
            super(name, isDirectory, parentDir);
            dirTable = new HashMap<>();
        }
    
        @Override
        public String toString() {
            return "Directory{" +
                    "dirTable=" + dirTable +
                    ", name='" + name + '\'' +
                    ", isDirectory=" + isDirectory +
                    ", parentDir=" + parentDir +
                    '}';
        }
    }
    ```

- DiskCosnt类

  该类存储了虚拟磁盘的相关常量属性以及序列化地址。

  ```java
  public class DiskConst {
      /**
       * 磁盘常量
       *      常量名               单位                    描述
       *      DISK_SIZE           VirtualBlock            磁盘容量
       *      SYSTEM_SIZE         VirtualBlock            系统分区
       *      USER_SIZE           VirtualBlock            用户分区
       *      TABLE_SIZE          VirtualBlock            组表容量
       *      BLOCK_SIZE          Character               虚拟块容量
       * */
      public static int DISK_SIZE = 12000;
      public static int BLOCK_SIZE = 100;
      public static String SerializePath = "fileSystem.txt";
  }
  ```

- VirtualBlock类

  该类为虚拟磁盘的基本单位，这里设置虚拟块大小为100个字符。该类有5个成员变量：

  - blockSize：虚拟块大小
  - blockID：虚拟块ID
  - freeSize：虚拟块空闲空间
  - isUSED：虚拟块是否被使用
  - content：虚拟块内容，用于存储数据

  主要有三个函数分别实现虚拟块的读取、写入和清空：

  - readBlock：读取虚拟块内容
  - writeBLock：写入虚拟块内容
  - clearBLock：清空虚拟块

- VirtualDisk类

  虚拟磁盘类，该类可用于文件系统存储文件和读出文件。该类主要有四个变量：

  - diskName：虚拟磁盘名
  - diskBlocks：虚拟块数组，为磁盘的存储空间
  - blockUsage：虚拟块使用情况，通过位示图实现
  - isFull：用来标志磁盘是否已满

  该类主要有两个函数用于实现磁盘空间的分配和释放：

  - diskAlloc：分配磁盘空间函数，通过输入需要分配的块数，返回请求的虚拟块的ID列表。
  - diskFree：回收磁盘空间函数，通过输入磁盘ID列表释放相应的磁盘块。

- VirtualFile类

  虚拟文件类，类似于Unix中的inode节点，存储了文件的其他属性。主要包含文件的大小、文件打开情况、文件缓冲区以及文件逻辑块和磁盘块的对应关系。该类并不实际存储文件的内容，仅仅保留文件逻辑块和虚拟块的对应关系，但是提供一个缓冲区，当文件打开时，会将文件读出并载入缓冲区，当文件关闭时，将缓冲区的文件内容写入到虚拟磁盘中。

  该类主要有五个函数：

  - isOpen：返回该文件是否被打开。
  - setOpen：设置文件打开标志，当打开文件时，将文件从磁盘加载到文件缓冲区；当关闭文件时，将文件从文件缓冲区写入到磁盘。
  - getContent：文件打开时，文件缓冲区存有文件的内容，将文件缓冲区的内容返回。
  - setContent：文件打开时，文件缓冲区存有文件的内容，通过输入的模式选择对文件内容的修改。
  - fileClear：删除文件时需要调用该函数。当文件关闭时，释放文件原本占有的磁盘空间的物理虚拟块。

- SimpleFileSystem类

  文件系统类自身。当开始执行文件系统时，运行该类的run函数，该函数不断读取终端输入的指令并进行执行。主要变量有根目录，当前目录，当前路径，虚拟磁盘和系统标准输入。函数包含了该实验要求的全部功能，会在算法流程中进行详细解释说明。

### 3. 算法处理流程

当程序开始运行后，首先在Main函数中读取命令，当读取到new命令时，新建文件系统；当读到sfs命令时，进入文件管理系统并运行文件系统类的run函数；当输入exit命令时，退出当前程序（即退出终端）。

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        SimpleFileSystem fileSystem = null;
        Scanner in = new Scanner(System.in);
        label:
        while (true) {
            System.out.print("> ");
            String command = in.next();
            switch (command) {
                // 创建文件系统
                case "new" -> {
                    if (fileSystem == null) {
                        System.out.println("VirtualFile System is created.");
                        fileSystem = new SimpleFileSystem();
                    } else {
                        System.out.println("VirtualFile System already exists.");
                    }
                }
                // 启动文件系统
                case "sfs" -> {
                    if (fileSystem != null) {
                        System.out.println("VirtualFile System is running.");
                        fileSystem.run();
                    } else {
                        System.out.println("VirtualFile System is not existed. You can use \"new\" to create one!");
                    }
                }
                // 退出终端
                case "exit" -> {
                    System.out.println("Exiting the shell.");
                    in.close();
                    break label;
                }
                default -> System.out.println("Invalid command.");
            }
        }
    }
}
```

使用sfs进入文件系统的run函数后，可以不断读入输入命令并执行相应的函数：

```java
public void run() {
    label:
    while (true) {
        System.out.print("fs> ");
        String command = in.next();
        String args;
        String buf;
        String rwMode;
        switch (command) {
            case "exit":
                // 退出文件系统
                System.out.println("Exiting the VirtualFile System.");
                saveFS(DiskConst.SerializePath);
                break label;
            case "mkdir":
                // 创建目录
                args = in.next();
                mkdir(args);
                break;
            case "rmdir":
                // 删除目录
                args = in.next();
                rmdir(args);
                break;
            case "ls":
                // 显示当前目录下所有文件和目录
                ls();
                break;
            case "pwd":
                // 显示当前路径
                pwd();
                break;
            case "cd":
                // 切换路径
                args = in.next();
                cd(args);
                break;
            case "create":
                // 新建文件
                args = in.next();
                createFile(args);
                break;
            case "delete":
                // 删除文件
                args = in.next();
                deleteFile(args);
                break;
            case "open":
                // 打开文件文件
                args = in.next();
                openFile(args);
                break;
            case "close":
                // 关闭文件
                args = in.next();
                closeFile(args);
                break;
            case "read":
                // 读取文件
                args = in.next();
                buf = readFile(args);
                if (buf != null) {
                    System.out.println(args + " contents:\n" + buf);
                } else {
                    System.out.println("Failed: Read failed. Nothing will be changed.");
                }
                break;
            case "write":
                args = in.next();
                buf = in.next();
                rwMode = in.next();
                writeFile(args, buf, rwMode);
                break;
            default:
                System.out.println("Invalid command.");
        }
    }
}
```

- exit命令

  输入该命令后，将文件系统和磁盘保存，并退出run函数，即返回到终端。

- mkdir命令

  首先检查目录名的合法性，若合法且不重复，则添加到当前目录的目录项表中。

  ```java
  private void mkdir(String dirName) {
      if (dirName.equals(".") || dirName.equals("..") || dirName.contains("/")) {
          // 文件名不能为"."或者".."，并且不能包含"/"
          System.out.println("Failed: Invalid directory name!");
          System.out.println("Directory name should not be \".\" or contains \"/\".");
      } else if (currentDir.dirTable.containsKey(dirName)) {
          // 检查同名文件夹或者文件是否已经存在
          System.out.println("Failed: " + dirName + " is already existed.");
      } else {
          // 当以上条件均正确无误时将目录项添加至 dirTable 中
          currentDir.dirTable.put(dirName, new Directory(dirName, true, currentDir));
          System.out.println(dirName + " is created.");
      }
  }
  ```

- rmdir命令

  1. 首先保存当前路径
  2. 检查目录名合法性
  3. 若文件夹为空则直接删除该文件夹的目录项目
  4. 若文件夹不为空则询问用户是否删除该目录及其目录下所有文件，若同意则递归删除所有文件和目录的目录项及其内容，最后当该目录清空后，删除该目录。
  5. 恢复当前路径
  6. 注：该函数需要使用cd函数进行辅助，由于时间问题还未改进，后续可能使用栈等改进该功能。

  ```java
  private void rmdir(String dirName) {
      // TODO：使用栈来简化
      // 暂存当前目录以及文件夹
      Directory stashCurrDir = currentDir;
      String stashCurrentPath = currentPath;
      // 目录名称存在并且类型为目录
      if (currentDir.dirTable.containsKey(dirName) && currentDir.dirTable.get(dirName).isDirectory) {
          Directory tmpDir = (Directory) currentDir.dirTable.get(dirName);
          if (tmpDir.dirTable.isEmpty()) {
              // 当文件目录为空时，可以删除当前目录
              currentDir.dirTable.remove(dirName);
              System.out.println(dirName + " is removed.");
          } else {
              // 当文件夹不为空时，询问是否要递归删除全部内容
              System.out.println("""
                      Failed: Current directory is not empty.
                      Do you want to remove all files and folders in this folder?
                      Enter "Y" or "y" to continue, otherwise nothing will be changed.""");
              String answer = in.next();
              if (answer.equals("Y") || answer.equals("y")) {
                  // 确认清理
                  cd("./" + dirName);
                  for (String fName : currentDir.dirTable.keySet()) {
                      if (currentDir.dirTable.get(fName).isDirectory) {
                          // 递归删除文件夹
                          r_rmdir(fName);
                      } else {
                          // 递归删除文件
                          deleteFile(fName);
                      }
                  }
                  cd("./..");
                  currentDir.dirTable.remove(dirName);
                  System.out.println(dirName + " is removed.");
              } else {
                  // 不清理
                  System.out.println("Nothing will be changed.");
              }
          }
      } else {
          System.out.println("Failed: " + dirName + " is not existed.");
      }
      // 恢复目录
      currentDir = stashCurrDir;
      currentPath = stashCurrentPath;
  }
  ```

- ls命令

  该函数通过遍历当前目录项表，输出当前目录的所有文件和目录，目录名为紫色，函数名为浅蓝色。

  ```java
  private void ls() {
      pwd();
      // 目录为紫色；文件为浅蓝色。
      for (String name : currentDir.dirTable.keySet()) {
          if (currentDir.dirTable.get(name).isDirectory) {
              System.out.println("\033[35;4m" + name + "\033[0m");
          } else {
              System.out.println("\033[36;4m" + name + "\033[0m");
          }
      }
  }
  ```

- pwd命令

  该函数可以输出当前路径。

  ```java
  private void pwd() {
      int reduceLength = 0;
      // 对是否在根目录下进行特别判断
      if (currentPath.length() > 1) {
          reduceLength = 1;
      }
      // 输出当前路径
      System.out.println("\033[32;4m" + "Current Path: " +
              currentPath.substring(0, currentPath.length() - reduceLength) + "\033[0m");
  }
  ```

- cd命令

  该函数为改变目录的函数。

  1. 首先对根目录进行特判，若为根目录则直接返回至根目录
  2. 随后判断是输入地址从当前目录还是根目录开始，并初步检查命令格式
  3. 若命令格式正确则开始解析目录
     - 若文件名存在并且为目录，则进入下一层目录
     - 若文件名为`..`则返回上一层目录
  4. 最后若解析过程完成，即中间没有中断，则说明成功进入指定目录

  ```java
  private void cd(String path) {
      boolean parseFinished = true;                       // 判断解析是否全部完成
      boolean correctCmd = false;                         // 判断输入命令是否符合格式
      Directory tmpCurrDir = null;                        // 临时Dir变量
      StringBuilder tmpPath = null;                       // 临时Path变量
      String dirName;                                     // 临时DirName变量
      String[] directories = path.split("/");       // 地址分割成块
      // 对返回根目录进行特判
      if (path.equals("/")) {
          currentDir = root;
          currentPath = "/";
      } else {
          // 判断是从当前目录开始还是从根目录开始解析地址
          if (directories[0].equals(".")) {
              correctCmd = true;
              tmpCurrDir = currentDir;
              tmpPath = new StringBuilder(currentPath);
          } else if (directories[0].equals("")) {
              correctCmd = true;
              tmpCurrDir = root;
              tmpPath = new StringBuilder("/");
          }
          // 若命令格式正确则开始解析路径
          if (correctCmd) {
              for (int i = 1; i < directories.length; i++) {
                  dirName = directories[i];
                  // 文件目录项存在且类型为目录，这里利用了短路运算
                  if (tmpCurrDir.dirTable.containsKey(dirName) && tmpCurrDir.dirTable.get(dirName).isDirectory) {
                      // 访问下一层
                      tmpCurrDir = (Directory) tmpCurrDir.dirTable.get(dirName);
                      tmpPath.append(dirName).append("/");
                  } else if (dirName.equals("..") && tmpCurrDir.parentDir != null) {
                      // 访问上一层
                      tmpCurrDir = tmpCurrDir.parentDir;
                      tmpPath = new StringBuilder(tmpPath.substring(0, tmpPath.length() - currentDir.name.length() - 1));
                  } else {
                      // 错误处理
                      parseFinished = false;
                      System.out.println("Failed: " + tmpPath + dirName + " is not existed");
                      break;
                  }
              }
              if (parseFinished) {
                  currentDir = tmpCurrDir;
                  currentPath = tmpPath.toString();
              }
          } else {
              System.out.println("Failed: Invalid cd command.The first character should be \"/\" or \".\"");
          }
  
      }
  }
  ```

- create命令

  首先检查要创建的文件名是否合法，合法则新建文件目录项。

  ```java
  private void createFile(String fileName) {
      if (fileName.equals(".") || fileName.equals("..") || fileName.contains("/")) {
          // 文件名不能为"."或者".."，并且不能包含"/"
          System.out.println("Failed: Invalid directory name!");
          System.out.println("Directory name should not be \".\" or contains \"/\".");
      } else if (currentDir.dirTable.containsKey(fileName)) {
          // 检查同名文件夹或者文件是否已经存在
          System.out.println("Failed: " + fileName + " is already existed.");
      } else {
          // 当以上条件均正确无误时将目录项添加至 dirTable 中
          // 使用Lazy分配策略，创建文件时不分配空间，文件写入时分配空间，这里仅需要添加目录项目即可。
          currentDir.dirTable.put(fileName, new DirectoryFile(fileName, false, currentDir));
          System.out.println(fileName + " is created.");
      }
  }
  ```

- delete命令

  首先检查文件名是否合法，若合法且文件存在则删除文件目录项并释放文件占有的空间。

  ```java
  private void deleteFile(String fileName) {
      if (currentDir.dirTable.containsKey(fileName) && !currentDir.dirTable.get(fileName).isDirectory) {
          // 回收空间
          DirectoryFile tmpFile = (DirectoryFile) currentDir.dirTable.get(fileName);
          if (tmpFile.file.fileClear(this.vDisk)) {
              // 删除文件目录项
              currentDir.dirTable.remove(fileName);
              System.out.println(fileName + " is removed.");
          }
      } else {
          System.out.println("Failed: " + fileName + " is not existed.");
      }
  }
  ```

- open命令

  首先检查文件名是否合法，若合法且文件存在则将文件属性isOpen设置为true。

  ```java
  private void openFile(String fileName) {
      if (currentDir.dirTable.containsKey(fileName) && !currentDir.dirTable.get(fileName).isDirectory) {
          // 文件存在时
          // 文件标记为打开
          DirectoryFile tmpFile = (DirectoryFile) currentDir.dirTable.get(fileName);
          // 从磁盘中读取buffer
          tmpFile.file.setOpen(true, this.vDisk);
          System.out.println(fileName + " is open.");
      } else {
          System.out.println("Failed: " + fileName + " is not existed.");
      }
  }
  ```

- close命令

  首先检查文件名是否合法，若合法且文件存在则将文件属性isOpen设置为false。

  ```java
  private void closeFile(String fileName) {
      if (currentDir.dirTable.containsKey(fileName) && !currentDir.dirTable.get(fileName).isDirectory) {
          // 文件存在时
          // 文件标记为关闭
          DirectoryFile tmpFile = (DirectoryFile) currentDir.dirTable.get(fileName);
          // 将 buffer 写入磁盘中
          tmpFile.file.setOpen(false, this.vDisk);
          System.out.println(fileName + " is closed.");
      } else {
          System.out.println("Failed: " + fileName + " is not existed.");
      }
  }
  ```

- read命令

  首先检查文件名是否合法，若合法且文件存在则将运行文件的读取指令，从文件的buffer获取文件的内容。

  ```java
  private String readFile(String fileName) {
      String buffer = null;
      if (currentDir.dirTable.containsKey(fileName) && !currentDir.dirTable.get(fileName).isDirectory) {
          // 文件存在时
          System.out.println("Loading...");
          DirectoryFile tmpFile = (DirectoryFile) currentDir.dirTable.get(fileName);
          // 当文件打开时
          if (tmpFile.file.isOpen()) {
              buffer = tmpFile.file.getContent();
          } else {
              System.out.println("Failed: " + fileName + " is not opened.");
          }
      } else {
          System.out.println("Failed: " + fileName + " is not existed.");
      }
      return buffer;
  }
  ```

- write命令

  首先检查文件名是否合法，若合法且文件存在则将运行文件的写入指令，将从终端获取的内容根据输入的模式写入到文件的缓冲区中。

  ```java
  private void writeFile(String fileName, String buf, String mode) {
      if (currentDir.dirTable.containsKey(fileName) && !currentDir.dirTable.get(fileName).isDirectory) {
          // 文件存在时
          System.out.println("Loading...");
          DirectoryFile tmpFile = (DirectoryFile) currentDir.dirTable.get(fileName);
          // 当文件打开时
          if (tmpFile.file.isOpen() && (mode.equals("a") || mode.equals("w"))) {
              tmpFile.file.setContent(buf, mode);
              System.out.println(fileName + " has been written.");
          } else if (tmpFile.file.isOpen() && !(mode.equals("a") || mode.equals("w"))) {
              System.out.println("Failed: Invalid mode " + mode + ".");
          } else {
              System.out.println("Failed: " + fileName + " is not opened.");
          }
      } else {
          System.out.println("Failed: " + fileName + " is not existed.");
      }
  }
  
  ```



### 4. 源程序及注释

完整源代码及注释如下：

- Main类

  ```java
  import java.util.Scanner;
  
  public class Main {
      public static void main(String[] args) {
          SimpleFileSystem fileSystem = null;
          Scanner in = new Scanner(System.in);
          label:
          while (true) {
              System.out.print("> ");
              String command = in.next();
              switch (command) {
                  // 创建文件系统
                  case "new" -> {
                      if (fileSystem == null) {
                          System.out.println("VirtualFile System is created.");
                          fileSystem = new SimpleFileSystem();
                      } else {
                          System.out.println("VirtualFile System already exists.");
                      }
                  }
                  // 启动文件系统
                  case "sfs" -> {
                      if (fileSystem != null) {
                          System.out.println("VirtualFile System is running.");
                          fileSystem.run();
                      } else {
                          System.out.println("VirtualFile System is not existed. You can use \"new\" to create one!");
                      }
                  }
                  // 退出终端
                  case "exit" -> {
                      System.out.println("Exiting the shell.");
                      in.close();
                      break label;
                  }
                  default -> System.out.println("Invalid command.");
              }
          }
      }
  }
  ```

- SimpleFileSystem类

  ```java
  import java.io.*;
  import java.util.Scanner;
  
  public class SimpleFileSystem {
  
      private static Directory root = new Directory("/", true, null); // 根目录
      private final Scanner in;           // 命令接受器
      private Directory currentDir;       // 当前目录项
      private String currentPath;         // 当前路径
      private VirtualDisk vDisk;          // 虚拟磁盘
  
      public SimpleFileSystem() {
          this.currentDir = root;
          this.currentPath = "/";
          this.vDisk = new VirtualDisk("/dev/sda");
          this.in = new Scanner(System.in);
          File f = new File(DiskConst.SerializePath);
          if (f.exists()) {
              loadFS(DiskConst.SerializePath);
          }
      }
  
      public void loadFS(String path) {
          try {
              FileInputStream in = new FileInputStream(path);
              ObjectInputStream iin = new ObjectInputStream(in);
              this.vDisk = (VirtualDisk) iin.readObject();
              root = (Directory) iin.readObject();
          } catch (IOException | ClassNotFoundException e) {
              throw new RuntimeException(e);
          }
      }
  
      public void saveFS(String path) {
          try {
              FileOutputStream fileOut = new FileOutputStream(path);
              ObjectOutputStream out = new ObjectOutputStream(fileOut);
              out.writeObject(this.vDisk);
              out.writeObject(root);
              out.close();
              fileOut.close();
          } catch (IOException e) {
              throw new RuntimeException(e);
          }
      }
  
      // 创建目录
      private void mkdir(String dirName) {
          if (dirName.equals(".") || dirName.equals("..") || dirName.contains("/")) {
              // 文件名不能为"."或者".."，并且不能包含"/"
              System.out.println("Failed: Invalid directory name!");
              System.out.println("Directory name should not be \".\" or contains \"/\".");
          } else if (currentDir.dirTable.containsKey(dirName)) {
              // 检查同名文件夹或者文件是否已经存在
              System.out.println("Failed: " + dirName + " is already existed.");
          } else {
              // 当以上条件均正确无误时将目录项添加至 dirTable 中
              currentDir.dirTable.put(dirName, new Directory(dirName, true, currentDir));
              System.out.println(dirName + " is created.");
          }
      }
  
      // 删除目录
      private void rmdir(String dirName) {
          // TODO：使用栈来简化
          // 暂存当前目录以及文件夹
          Directory stashCurrDir = currentDir;
          String stashCurrentPath = currentPath;
          // 目录名称存在并且类型为目录
          if (currentDir.dirTable.containsKey(dirName) && currentDir.dirTable.get(dirName).isDirectory) {
              Directory tmpDir = (Directory) currentDir.dirTable.get(dirName);
              if (tmpDir.dirTable.isEmpty()) {
                  // 当文件目录为空时，可以删除当前目录
                  currentDir.dirTable.remove(dirName);
                  System.out.println(dirName + " is removed.");
              } else {
                  // 当文件夹不为空时，询问是否要递归删除全部内容
                  System.out.println("""
                          Failed: Current directory is not empty.
                          Do you want to remove all files and folders in this folder?
                          Enter "Y" or "y" to continue, otherwise nothing will be changed.""");
                  String answer = in.next();
                  if (answer.equals("Y") || answer.equals("y")) {
                      // 确认清理
                      cd("./" + dirName);
                      for (String fName : currentDir.dirTable.keySet()) {
                          if (currentDir.dirTable.get(fName).isDirectory) {
                              // 递归删除文件夹
                              r_rmdir(fName);
                          } else {
                              // 递归删除文件
                              deleteFile(fName);
                          }
                      }
                      cd("./..");
                      currentDir.dirTable.remove(dirName);
                      System.out.println(dirName + " is removed.");
                  } else {
                      // 不清理
                      System.out.println("Nothing will be changed.");
                  }
              }
          } else {
              System.out.println("Failed: " + dirName + " is not existed.");
          }
          // 恢复目录
          currentDir = stashCurrDir;
          currentPath = stashCurrentPath;
      }
  
      private void r_rmdir(String dirName) {
          // 递归删除器
          // 暂存当前目录以及文件夹
          Directory stashCurrDir = currentDir;
          String stashCurrentPath = currentPath;
          // 目录名称存在并且类型为目录
          if (currentDir.dirTable.containsKey(dirName) && currentDir.dirTable.get(dirName).isDirectory) {
              Directory tmpDir = (Directory) currentDir.dirTable.get(dirName);
              if (tmpDir.dirTable.isEmpty()) {
                  // 当文件目录为空时，可以删除当前目录
                  currentDir.dirTable.remove(dirName);
                  System.out.println(dirName + " is removed.");
              } else {
                  // 递归清理
                  cd("./" + dirName);
                  for (String fName : currentDir.dirTable.keySet()) {
                      if (currentDir.dirTable.get(fName).isDirectory) {
                          // 递归删除文件夹
                          r_rmdir(fName);
                      } else {
                          // 递归删除文件
                          deleteFile(fName);
                      }
                  }
                  cd("./..");
                  currentDir.dirTable.remove(dirName);
                  System.out.println(dirName + " is removed.");
              }
          } else {
              System.out.println("Failed: " + dirName + " is not existed.");
          }
          // 恢复目录
          currentDir = stashCurrDir;
          currentPath = stashCurrentPath;
      }
  
      // 显示当前目录下所有目录项
      private void ls() {
          pwd();
          // 目录为紫色；文件为浅蓝色。
          for (String name : currentDir.dirTable.keySet()) {
              if (currentDir.dirTable.get(name).isDirectory) {
                  System.out.println("\033[35;4m" + name + "\033[0m");
              } else {
                  System.out.println("\033[36;4m" + name + "\033[0m");
              }
          }
      }
  
      // 显示当前目录地址
      private void pwd() {
          int reduceLength = 0;
          // 对是否在根目录下进行特别判断
          if (currentPath.length() > 1) {
              reduceLength = 1;
          }
          // 输出当前路径
          System.out.println("\033[32;4m" + "Current Path: " +
                  currentPath.substring(0, currentPath.length() - reduceLength) + "\033[0m");
      }
  
      // 改变当前目录
      private void cd(String path) {
          boolean parseFinished = true;                       // 判断解析是否全部完成
          boolean correctCmd = false;                         // 判断输入命令是否符合格式
          Directory tmpCurrDir = null;                        // 临时Dir变量
          StringBuilder tmpPath = null;                       // 临时Path变量
          String dirName;                                     // 临时DirName变量
          String[] directories = path.split("/");       // 地址分割成块
          // 对返回根目录进行特判
          if (path.equals("/")) {
              currentDir = root;
              currentPath = "/";
          } else {
              // 判断是从当前目录开始还是从根目录开始解析地址
              if (directories[0].equals(".")) {
                  correctCmd = true;
                  tmpCurrDir = currentDir;
                  tmpPath = new StringBuilder(currentPath);
              } else if (directories[0].equals("")) {
                  correctCmd = true;
                  tmpCurrDir = root;
                  tmpPath = new StringBuilder("/");
              }
              // 若命令格式正确则开始解析路径
              if (correctCmd) {
                  for (int i = 1; i < directories.length; i++) {
                      dirName = directories[i];
                      // 文件目录项存在且类型为目录，这里利用了短路运算
                      if (tmpCurrDir.dirTable.containsKey(dirName) && tmpCurrDir.dirTable.get(dirName).isDirectory) {
                          // 访问下一层
                          tmpCurrDir = (Directory) tmpCurrDir.dirTable.get(dirName);
                          tmpPath.append(dirName).append("/");
                      } else if (dirName.equals("..") && tmpCurrDir.parentDir != null) {
                          // 访问上一层
                          tmpCurrDir = tmpCurrDir.parentDir;
                          tmpPath = new StringBuilder(tmpPath.substring(0, tmpPath.length() - currentDir.name.length() - 1));
                      } else {
                          // 错误处理
                          parseFinished = false;
                          System.out.println("Failed: " + tmpPath + dirName + " is not existed");
                          break;
                      }
                  }
                  if (parseFinished) {
                      currentDir = tmpCurrDir;
                      currentPath = tmpPath.toString();
                  }
              } else {
                  System.out.println("Failed: Invalid cd command.The first character should be \"/\" or \".\"");
              }
  
          }
      }
  
      private void createFile(String fileName) {
          if (fileName.equals(".") || fileName.equals("..") || fileName.contains("/")) {
              // 文件名不能为"."或者".."，并且不能包含"/"
              System.out.println("Failed: Invalid directory name!");
              System.out.println("Directory name should not be \".\" or contains \"/\".");
          } else if (currentDir.dirTable.containsKey(fileName)) {
              // 检查同名文件夹或者文件是否已经存在
              System.out.println("Failed: " + fileName + " is already existed.");
          } else {
              // 当以上条件均正确无误时将目录项添加至 dirTable 中
              // 使用Lazy分配策略，创建文件时不分配空间，文件写入时分配空间，这里仅需要添加目录项目即可。
              currentDir.dirTable.put(fileName, new DirectoryFile(fileName, false, currentDir));
              System.out.println(fileName + " is created.");
          }
      }
  
      private void deleteFile(String fileName) {
          if (currentDir.dirTable.containsKey(fileName) && !currentDir.dirTable.get(fileName).isDirectory) {
              // 回收空间
              DirectoryFile tmpFile = (DirectoryFile) currentDir.dirTable.get(fileName);
              if (tmpFile.file.fileClear(this.vDisk)) {
                  // 删除文件目录项
                  currentDir.dirTable.remove(fileName);
                  System.out.println(fileName + " is removed.");
              }
          } else {
              System.out.println("Failed: " + fileName + " is not existed.");
          }
      }
  
      private void openFile(String fileName) {
          if (currentDir.dirTable.containsKey(fileName) && !currentDir.dirTable.get(fileName).isDirectory) {
              // 文件存在时
              // 文件标记为打开
              DirectoryFile tmpFile = (DirectoryFile) currentDir.dirTable.get(fileName);
              // 从磁盘中读取buffer
              tmpFile.file.setOpen(true, this.vDisk);
              System.out.println(fileName + " is open.");
          } else {
              System.out.println("Failed: " + fileName + " is not existed.");
          }
      }
  
      private void closeFile(String fileName) {
          if (currentDir.dirTable.containsKey(fileName) && !currentDir.dirTable.get(fileName).isDirectory) {
              // 文件存在时
              // 文件标记为关闭
              DirectoryFile tmpFile = (DirectoryFile) currentDir.dirTable.get(fileName);
              // 将 buffer 写入磁盘中
              tmpFile.file.setOpen(false, this.vDisk);
              System.out.println(fileName + " is closed.");
          } else {
              System.out.println("Failed: " + fileName + " is not existed.");
          }
      }
  
      // read && write 均在 buffer 中进行
      private String readFile(String fileName) {
          String buffer = null;
          if (currentDir.dirTable.containsKey(fileName) && !currentDir.dirTable.get(fileName).isDirectory) {
              // 文件存在时
              System.out.println("Loading...");
              DirectoryFile tmpFile = (DirectoryFile) currentDir.dirTable.get(fileName);
              // 当文件打开时
              if (tmpFile.file.isOpen()) {
                  buffer = tmpFile.file.getContent();
              } else {
                  System.out.println("Failed: " + fileName + " is not opened.");
              }
          } else {
              System.out.println("Failed: " + fileName + " is not existed.");
          }
          return buffer;
      }
  
      private void writeFile(String fileName, String buf, String mode) {
          if (currentDir.dirTable.containsKey(fileName) && !currentDir.dirTable.get(fileName).isDirectory) {
              // 文件存在时
              System.out.println("Loading...");
              DirectoryFile tmpFile = (DirectoryFile) currentDir.dirTable.get(fileName);
              // 当文件打开时
              if (tmpFile.file.isOpen() && (mode.equals("a") || mode.equals("w"))) {
                  tmpFile.file.setContent(buf, mode);
                  System.out.println(fileName + " has been written.");
              } else if (tmpFile.file.isOpen() && !(mode.equals("a") || mode.equals("w"))) {
                  System.out.println("Failed: Invalid mode " + mode + ".");
              } else {
                  System.out.println("Failed: " + fileName + " is not opened.");
              }
          } else {
              System.out.println("Failed: " + fileName + " is not existed.");
          }
      }
  
      public void run() {
          label:
          while (true) {
              System.out.print("fs> ");
              String command = in.next();
              String args;
              String buf;
              String rwMode;
              switch (command) {
                  case "exit":
                      // 退出文件系统
                      System.out.println("Exiting the VirtualFile System.");
                      saveFS(DiskConst.SerializePath);
                      break label;
                  case "mkdir":
                      // 创建目录
                      args = in.next();
                      mkdir(args);
                      break;
                  case "rmdir":
                      // 删除目录
                      args = in.next();
                      rmdir(args);
                      break;
                  case "ls":
                      // 显示当前目录下所有文件和目录
                      ls();
                      break;
                  case "pwd":
                      // 显示当前路径
                      pwd();
                      break;
                  case "cd":
                      // 切换路径
                      args = in.next();
                      cd(args);
                      break;
                  case "create":
                      // 新建文件
                      args = in.next();
                      createFile(args);
                      break;
                  case "delete":
                      // 删除文件
                      args = in.next();
                      deleteFile(args);
                      break;
                  case "open":
                      // 打开文件文件
                      args = in.next();
                      openFile(args);
                      break;
                  case "close":
                      // 关闭文件
                      args = in.next();
                      closeFile(args);
                      break;
                  case "read":
                      // 读取文件
                      args = in.next();
                      buf = readFile(args);
                      if (buf != null) {
                          System.out.println(args + " contents:\n" + buf);
                      } else {
                          System.out.println("Failed: Read failed. Nothing will be changed.");
                      }
                      break;
                  case "write":
                      args = in.next();
                      buf = in.next();
                      rwMode = in.next();
                      writeFile(args, buf, rwMode);
                      break;
                  default:
                      System.out.println("Invalid command.");
              }
          }
      }
  }
  
  ```

- DirectoryEntry类

  ```java
  import java.io.Serializable;
  
  public abstract class DirectoryEntry implements Serializable {
      public String name;                     // 文件名/目录名
      public boolean isDirectory;             // 目录标志
      public Directory parentDir;             // 父目录
  
      public DirectoryEntry(String name, boolean isDirectory, Directory parentDir) {
          this.name = name;
          this.isDirectory = isDirectory;
          this.parentDir = parentDir;
      }
  
      @Override
      public String toString() {
          return "DirectoryEntry{" +
                  "name='" + name + '\'' +
                  ", isDirectory=" + isDirectory +
                  ", parentDir=" + parentDir +
                  '}';
      }
  }
  
  ```

- Directory类

  ```java
  import java.io.Serializable;
  import java.util.HashMap;
  
  public class Directory extends DirectoryEntry implements Serializable {
      public HashMap<String, DirectoryEntry> dirTable;        // 目录表
  
      public Directory(String name, boolean isDirectory, Directory parentDir) {
          super(name, isDirectory, parentDir);
          dirTable = new HashMap<>();
      }
  
      @Override
      public String toString() {
          return "Directory{" +
                  "dirTable=" + dirTable +
                  ", name='" + name + '\'' +
                  ", isDirectory=" + isDirectory +
                  ", parentDir=" + parentDir +
                  '}';
      }
  }
  ```

- DirectoryFile类

  ```java
  import java.io.Serializable;
  
  public class DirectoryFile extends DirectoryEntry implements Serializable {
      /*
       * 文件目录项
       * - 文件由文件控制块和文件体组成。
       * - 文件控制块由文件目录项和文件索引节点（inode 节点）组成。
       * - 文件目录项中包含了文件的名称和文件索引节点号（inode 节点号），通过文件文件索引节点号即可访问文件索引节点。
       * - 文件索引节点中包含了文件的其他属性，例如文件大小、文件打开标志、文件索引表。
       * - 文件索引表存储了文件逻辑块号和物理块号的对应关系。
       * - 本实验由 Java 实现，在 Java 中对象为引用类型，类似于 C 语言中的指针，因此不需要在文件目录项目中设置文件索引节点号，
       *   而是直接设置一个文件对象即可。
       */
      public VirtualFile file;                       // 文件
  
      public DirectoryFile(String name, boolean isDirectory, Directory parentDir) {
          super(name, isDirectory, parentDir);
          this.file = new VirtualFile();
      }
  
      @Override
      public String toString() {
          return "DirectoryFile{" +
                  "virtualFile=" + file +
                  ", name='" + name + '\'' +
                  ", isDirectory=" + isDirectory +
                  ", parentDir=" + parentDir +
                  '}';
      }
  }
  ```

- VirtualDisk类

  ```java
  import java.io.Serializable;
  import java.util.ArrayList;
  import java.util.Arrays;
  
  public class VirtualDisk implements Serializable {
      public String diskName;                 // 虚拟磁盘名
      public VirtualBlock[] diskBlocks;       // 虚拟块表
      public int[] blockUsage;                // 虚拟块占用表
      private boolean isFull;                 // 磁盘是否已满
  
      public VirtualDisk(String diskName) {
          this.diskName = diskName;
          this.diskBlocks = new VirtualBlock[DiskConst.DISK_SIZE];
          this.blockUsage = new int[DiskConst.DISK_SIZE];
          this.isFull = false;
          // 初始化块
          for (int i = 0; i < DiskConst.DISK_SIZE; i++) {
              this.diskBlocks[i] = new VirtualBlock(i);
              this.blockUsage[i] = 0;
          }
      }
  
      public ArrayList<Integer> diskAlloc(int num) {
          ArrayList<Integer> idxBuffer = new ArrayList<>();
          for (int i = 0; i < num; i++) {
              for (int j = 0; j < DiskConst.DISK_SIZE; j++) {
                  if (blockUsage[j] == 0) {
                      idxBuffer.add(j);
                      blockUsage[j] = 1;
                      break;
                  }
              }
          }
          return idxBuffer;
      }
  
      public void diskFree(ArrayList<Integer> idxBuffer) {
          for (Integer idx : idxBuffer) {
              diskBlocks[idx].clearBlock();
              blockUsage[idx] = 0;
          }
      }
  
      public void diskUsage() {
          if (isFull()) {
              System.out.println("Disk is used up.");
          } else {
              int used = 0;
              for (int i = 0; i < DiskConst.DISK_SIZE; i++) {
                  used += blockUsage[i];
              }
              int usageRate = (int) (100.0 * used / DiskConst.DISK_SIZE);
              System.out.println("Disk Usage: " + usageRate + "%");
              System.out.println("Used blocks: " + used);
              System.out.println("Free blocks: " + (DiskConst.DISK_SIZE - used));
          }
      }
  
      public boolean isFull() {
          isFull = true;
          for (int i = 0; i < DiskConst.DISK_SIZE; i++) {
              if (!diskBlocks[i].isUSED()) {
                  isFull = false;
                  break;
              }
          }
          return isFull;
      }
  
      @Override
      public String toString() {
          return "VirtualDisk{" +
                  "diskName='" + diskName + '\'' +
                  ", diskBlocks=" + Arrays.toString(diskBlocks) +
                  ", blockUsage=" + Arrays.toString(blockUsage) +
                  ", isFull=" + isFull +
                  '}';
      }
  }
  ```

- VirtualBlock类

  ```java
  import java.io.Serializable;
  
  public class VirtualBlock implements Serializable {
      /**
       * 虚拟块类：
       *      用来标识磁盘和内存中的基本存储单位，模拟按字节编址（基本单元为字节），
       *      实际采用按照字符编址的方法，并以字符串对象代替字符数组，以简化操作流程。
       * 属性：
       *      块号：虚拟块的唯一标识。一旦创建则不可修改。
       *      块容量：虚拟块的容量大小。虚拟块容量默认设置为 100，代表一个虚拟块可以存储 100 个字符，即字符串长度不能超过 100。
       *      块空闲容量：虚拟块的空闲容量。当虚拟块未满时，记录虚拟块的剩余空间。
       *      块空闲标志：虚拟块的空闲标志。当虚拟块未满时，该标记未真，否则为假。在这里为了简化操作，该标志表示虚拟块是否被使用，
       *                若已被使用则未真，否则为假。
       *      块内容：虚拟块的内容。用于记录虚拟块的真实内容，这里使用字符串代替字符数组，以简化流程。
       * 方法：
       *      构造方法
       *      变量的 Get 方法和 Set 方法
       * 补充：
       *      若想将虚拟块模拟的更为细致，首先可以将内容变量的变量类型改为固定大小的字符数组，并调用字符串和字符数组的相互转换函数。
       *      但是在各个组件的数据传输中，仍然建议使用字符串进行传递，方便且高效。其次，可以设置 ArrayList<Integer> Position
       *      用来记录不同文件的分割之处的位置，并针对此添加 append 附加函数和 remove 删除函数，还需要对别的细节进行实现，这样
       *      就可以避免外部碎片的产生，提高存储占用率。
       * */
      private final static int blockSize = DiskConst.BLOCK_SIZE;      // 块容量
      private final int blockID;                                      // 块号
      private int freeSize;                                           // 块空闲容量
      private boolean isUSED;                                         // 块是否被占用
      private String content;                                         // 块内容
  
      public VirtualBlock(int blockID) {
          this.blockID = blockID;
          this.freeSize = blockSize;
          this.isUSED = false;
          this.content = "";
      }
  
      public int getBlockSize() {
          return blockSize;
      }
  
      public int getBlockID() {
          return blockID;
      }
  
      public boolean isUSED() {
          return isUSED;
      }
  
      public void setUSED(boolean USED) {
          isUSED = USED;
      }
  
      public String readBlock() {
          return content;
      }
  
      public void writeBlock(String content) {
          this.content = content;
          this.freeSize = blockSize - content.length();
          this.isUSED = true;
      }
  
      public void clearBlock() {
          this.content = "";
          this.freeSize = blockSize;
          this.isUSED = false;
      }
  
      @Override
      public String toString() {
          return "VirtualBlock{" +
                  "blockID=" + blockID +
                  ", freeSize=" + freeSize +
                  ", isUSED=" + isUSED +
                  ", content='" + content + '\'' +
                  '}';
      }
  }
  ```

- VirtualFile类

  ```java
  import java.io.Serializable;
  import java.util.ArrayList;
  import java.util.HashMap;
  
  public class VirtualFile implements Serializable {
      private final HashMap<Integer, Integer> indexTable;       // 文件索引表
      private int fileSize;                               // 文件大小
      private boolean isOpen;                             // 文件打开标志
      private String buffer;                              // 文件缓冲区
  
      public VirtualFile() {
          this.indexTable = new HashMap<>();
          this.fileSize = 0;
          this.isOpen = false;
          this.buffer = "";
      }
  
      public boolean isOpen() {
          return isOpen;
      }
  
      public void setOpen(boolean open, VirtualDisk vDisk) {
          // 打开文件时，将文件从磁盘加载到文件缓冲区；
          // 关闭文件时，将文件从文件缓冲区写入到磁盘；
          isOpen = open;
          if (isOpen) {
              // 清空文件缓冲区
              buffer = "";
              // 计算文件虚拟块数
              int blockNum = (int) Math.ceil(1.0 * fileSize / DiskConst.BLOCK_SIZE);
              // 将文件从磁盘加载到文件缓冲区
              for (int i = 0; i < blockNum; i++) {
                  int idx = indexTable.get(i);
                  buffer += vDisk.diskBlocks[idx].readBlock();
              }
          } else {
              // 计算文件大小
              fileSize = buffer.length();
              // 计算文件虚拟块数
              int blockNum = (int) Math.ceil(1.0 * fileSize / DiskConst.BLOCK_SIZE);
              // 从磁盘中申请空间
              ArrayList<Integer> blockBuf = vDisk.diskAlloc(blockNum);
              // 将文件按照虚拟块大小进行拆分
              ArrayList<String> contentBuf = new ArrayList<>();
              for (int i = 0; i < fileSize; i += DiskConst.BLOCK_SIZE) {
                  contentBuf.add(buffer.substring(i, Math.min(buffer.length(), i + DiskConst.BLOCK_SIZE)));
              }
              // 更新文件索引表并将文件内容写入到磁盘中
              for (int i = 0; i < blockNum; i++) {
                  int idx = blockBuf.get(i);
                  // 记录索引
                  indexTable.put(i, idx);
                  // 写入磁盘
                  vDisk.diskBlocks[idx].writeBlock(contentBuf.get(i));
              }
          }
      }
  
      public String getContent() {
          return buffer;
      }
  
      public void setContent(String content, String mode) {
          if (mode.equals("a")) {
              // 追加模式
              buffer += content;
          } else if (mode.equals("w")) {
              // 覆盖模式
              buffer = content;
          }
      }
  
      public boolean fileClear(VirtualDisk vDisk) {
          boolean isOK = false;
          if (!isOpen) {
              ArrayList<Integer> indexList = new ArrayList<>(indexTable.values());
              vDisk.diskFree(indexList);
              isOK = true;
          } else {
              System.out.println("Failed: This virtualFile is still open, please close it first.");
          }
          return isOK;
      }
  
      @Override
      public String toString() {
          return "VirtualFile{" +
                  "indexTable=" + indexTable +
                  ", fileSize=" + fileSize +
                  ", isOpen=" + isOpen +
                  ", buffer='" + buffer + '\'' +
                  '}';
      }
  }
  ```

### 5. 测试方法与结果

使用本地测试方法，所有命令皆可正常运行，并且在输入指令错误时反馈不同的错误。

- new：建立一个新的简单文件系统

  ![image-20230602202449783](../../../../../../Temp/TempResoures/image-20230602202449783.png)

- sfs：打开一个简单文件系统

  ![image-20230602202510576](../../../../../../Temp/TempResoures/image-20230602202510576.png)

- exit：退出打开的简单文件系统

  ![image-20230602202523992](../../../../../../Temp/TempResoures/image-20230602202523992.png)

- mkdir：创建子目录

  ![image-20230602202549933](../../../../../../Temp/TempResoures/image-20230602202549933.png)

- rmdir：删除子目录

  ![image-20230602202626090](../../../../../../Temp/TempResoures/image-20230602202626090.png)

- ls：显示目录

  ![image-20230602202603451](../../../../../../Temp/TempResoures/image-20230602202603451.png)

- cd：更改当前目录

  ![image-20230602202643480](../../../../../../Temp/TempResoures/image-20230602202643480.png)

- create：创建文件

  ![image-20230602202658241](../../../../../../Temp/TempResoures/image-20230602202658241.png)

- open：打开文件

  ![image-20230602202717779](../../../../../../Temp/TempResoures/image-20230602202717779.png)

- close：关闭文件

  ![image-20230602202910892](../../../../../../Temp/TempResoures/image-20230602202910892.png)

- read：读文件

  ![image-20230602202733251](../../../../../../Temp/TempResoures/image-20230602202733251.png)

  存入内容后重新打开文件

  ![image-20230602202943520](../../../../../../Temp/TempResoures/image-20230602202943520.png)

- write：写文件

  ![image-20230602202854062](../../../../../../Temp/TempResoures/image-20230602202854062.png)

- delete：删除文件

  ![image-20230602203015945](../../../../../../Temp/TempResoures/image-20230602203015945.png)

### 6. 实验经验和体会

实现文件系统是一种学习操作系统文件管理系统的有效方式。通过实验，可以深入理解文件管理系统的原理和功能，并通过实际操作来加深对操作系统的理解。首先本次实验使我更清楚地理解了文件和目录的概念，让我学会了如何创建、打开、读取和写入文件，以及如何组织文件和目录结构，并将其转换为代码。其次，我还设计了一些常用的文件操作命令，如创建文件和删除文件等。这些命令是进行文件管理的基础，对于有效地组织和操作文件至关重要。第三则是在实验中深化了文件权限和保护的概念。这对于保护文件的安全性和控制对文件的访问非常重要。虽然我并未实现完整的控制权限功能，但是也进行了一定的文件控制权限管理和异常处理，例如文件的打开标志。最后，在该实验中，我了解了不同的文件系统组织方式，如层次文件系统和索引文件系统等。我学会了如何分配存储空间和管理文件的物理存储位置，以提高文件的访问效率，并将这些设计尽我所能应用在我的文件系统的设计中。此外，我认为本次实验还我培养了解决问题的能力。在实验过程中，我遇到了一些常见的文件管理问题，如文件重名、文件夹嵌套和文件丢失等。通过思考和实践，我学会了如何解决这些问题，提高了自己的问题解决能力。
